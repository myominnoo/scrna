
# -------------------------------------------------------------------------
# -------------------------------------------------------------------------
#             scRNA seq analysis - AL Winnipeg
# -------------------------------------------------------------------------
# -------------------------------------------------------------------------

# Author: Myo Minn Oo
# Start date: 27/06/2022

# Prepare workspace\ ------------------------------------------------------

rm(list = ls())


## install required packages
# required_packages <- c("Seurat", "sctransform", "dplyr",
#                        "RColorBrewer", "ggthemes", "ggplot2",
#                        "cowplot", "data.table", 
#                        "ggraph","igraph","tidyverse", "data.tree",
#                        "HGNChelper", "openxlsx")
# install.packages(required_packages)
# 
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# BiocManager::install(C("scater", "limma"))


library("Seurat")
library("sctransform")
library("tidyverse")
library("RColorBrewer")
library("ggthemes")
library("ggplot2")
library("cowplot")
library("data.table")
library("patchwork")



## change constants here
outdir <- "output"
# folder.dir <- "filtered_feature_bc_matrix" # raw_feature_bc_matrix
folder.dir <- "raw_feature_bc_matrix"



samples <- paste0("AL", c("35","37","45", "47", "48", "49", "50B", "50C"))
data.dir <- grep("AL", dir("data"), value = TRUE)
full.dir <- paste("data", data.dir, folder.dir, sep = "/")



# step 1: import data -----------------------------------------------------

# Read in feature-barcode matrices generated by cellranger pipeline 
# first declare an empty list in which to hold the feature-barcode matrices
data.10x = list(); 
for (i in 1:length(full.dir)) {
  cat("Importing", full.dir[i], "\n")
  data.10x[[i]] <- Read10X(full.dir[i])
}

## checking the structure of the dgC matrix
str(data.10x)



# convert each feature-barcode matrix to 'SeuratObject'

# First create an empty list to hold the Seurat objects
scrna.list = list()
for (i in 1:length(data.10x)) {
  scrna.list[[i]] <- CreateSeuratObject(
    counts = data.10x[[i]], 
    min.cells = 3, 
    min.features = 100, 
    project = samples[i]
  )
  scrna.list[[i]][["DataSet"]] = samples[i]
}


## remove data.10x to save memory 
rm(data.10x);

## merge all samples into one file
scrna <- NULL
for (i in 2:length(full.dir)) {
  scrna <- c(scrna, scrna.list[[i]])
} 

scrna <- merge(x = scrna.list[[1]], 
               y = scrna, 
               add.cell.ids = samples[1:length(full.dir)], 
               project = "AL")

rm(scrna.list); # save some memory

str(scrna@meta.data) # examine the structure of the Seurat object meta data
table(scrna@meta.data$DataSet)

output_data <- paste(outdir, "data", sep = "/")
if (!dir.exists(output_data)) dir.create(output_data)

# saveRDS(scrna, sprintf("%s/MergedSeuratObject.rds", output_data))



# data.10x2 <- Read10X(full.dir)
# scrna2 <- CreateSeuratObject(
#   counts = data.10x2, 
#   min.cells = 3, 
#   min.features = 100, 
#   project = "AL"
# )
# str(scrna2)
# FeatureScatter(object = scrna2, 
#                feature1 = "nCount_RNA", 
#                feature2 = "nFeature_RNA", 
#                pt.size = 0.1)
# VlnPlot(scrna2, features = "nCount_RNA", y.max = 25000)
# VlnPlot(scrna2, features = "nFeature_RNA")
# scrna2@meta.data$orig.ident





# Step 2: Quality Control plots -------------------------------------------

# The [[ operator can add columns to object metadata. 
# This is a great place to stash QC stats
scrna[["percent.mito"]] <- PercentageFeatureSet(scrna, pattern = "^MT-")
scrna[["percent.ribo"]] <- PercentageFeatureSet(scrna, pattern = "^RP[SL][[:digit:]]")


## create directory to save qc plots 

output_qcplot <- paste(outdir, "plot", "qc", sep = "/")
if (!dir.exists(output_qcplot)) {
  dir.create(output_qcplot, recursive = TRUE)
}

## generate and save violin plots

## univariate plots
tiff(sprintf("%s/VlnPlot_uni.tiff", output_qcplot), 
     width = 15, height = 10, units = "in", res = 100)
VlnPlot(object = scrna, 
        features = c("nCount_RNA"),
        ncol = 2, 
        y.max = 20000, ## check the Vlnplot
        group.by = "DataSet", combine = TRUE) + 
  VlnPlot(object = scrna, 
        features = c("nCount_RNA", "nFeature_RNA", 
                     "percent.mito", "percent.ribo"),
        ncol = 2, 
        group.by = "DataSet", combine = TRUE)
   
dev.off()


## bivariate plots
tiff(sprintf("%s/VlnPlot_bi.tiff", output_qcplot), 
     width = 10, height = 7, units = "in", res = 100)

(FeatureScatter(object = scrna, 
               feature1 = "nCount_RNA", 
               feature2 = "nFeature_RNA", 
               pt.size = 0.1) +
  FeatureScatter(object = scrna, 
                 feature1 = "nCount_RNA", 
                 feature2 = "percent.mito", 
                 pt.size = 0.1)) / 
  (FeatureScatter(object = scrna, 
                 feature1 = "nFeature_RNA", 
                 feature2 = "percent.mito", 
                 pt.size = 0.1) + 
  FeatureScatter(object = scrna, 
                 feature1 = "percent.ribo", 
                 feature2 = "percent.mito", 
                 pt.size = 0.1)) 

dev.off()
  


## calculate cell cycle metrics
## cell cycle tirosh - list of genes
cct <- "http://genomedata.org/rnaseq-tutorial/scrna/CellCycleTiroshSymbol2ID.csv" 
cct <- readr::read_csv(cct)
s.genes <- cct %>% 
  filter(List == "G1/S") %>% 
  select(`Gene Symbol`) %>% 
  unlist(., use.names = FALSE)
g2m.genes <- cct %>% 
  filter(List == "G2/M") %>% 
  select(`Gene Symbol`) %>% 
  unlist(., use.names = FALSE)

scrna <- CellCycleScoring(object = scrna, 
                          s.features = s.genes, 
                          g2m.features = g2m.genes, 
                          set.ident = FALSE)


## create metrics for nFeature_RNA and nCount_RNA
scrna@meta.data %>%
  group_by(DataSet) %>% 
  summarise(
    n_gene = n(),
    n_FeatureRNA = sum(nFeature_RNA),
    min_fRNA = min(nFeature_RNA), 
    med_fRNA = median(nFeature_RNA), 
    max_fRNA = max(nFeature_RNA), 
    sd_fRNA = sd(nFeature_RNA), 
    n_countRNA = sum(nCount_RNA), 
    min_nRNA = min(nCount_RNA), 
    mean_nRNA = mean(nCount_RNA), 
    med_nRNA = median(nCount_RNA), 
    max_nRNA = max(nCount_RNA),
    sd_nRNA = sd(nCount_RNA),
    c90_nRNA = quantile(nCount_RNA, 0.9)
  ) %>% 
  write.csv("output/metrics_summary.csv", row.names = FALSE)


## subset data with good quality
scrna <- subset(x = scrna, subset = nFeature_RNA > 100  & 
                  nCount_RNA < 25000 & percent.mito < 25)


# Step 3: normalize and scale the data ------------------------------------

## noramlize using LogNormalzie with scale factor of 10000
scrna <- NormalizeData(object = scrna, 
                        normalization.method = "LogNormalize",
                        scale.factor = 10000)

## Scale the data 
scrna <- ScaleData(object = scrna, 
                   features = rownames(x = scrna), 
                   verbose=FALSE)


## second method is to scale the data and simultaneously remove 
## unwanted signals associated with variables such as 
## cell cycle phase, ribosomal transcript content.
## this is slow and may take a while.
# scrna2 <- ScaleData(object = scrna, 
#                     features = rownames(scrna), 
#                     vars.to.regress = c("S.Score","G2M.Score"), 
#                     display.progress = TRUE)


## find highly variable features 
scrna <- FindVariableFeatures(object = scrna, 
                              selection.method = 'vst', 
                              # mean.cutoff = c(0.1,8),
                              # dispersion.cutoff = c(1, Inf),
                              nfeatures = 2000)

# Identify the 10 most highly variable genes
top10.hvg <- head(VariableFeatures(scrna), 10)

output_plot <- paste(outdir, "plot", sep = "/")
tiff(sprintf("%s/HVG.tiff", output_plot), 
     width = 10, height = 7, units = "in", res = 90)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(scrna)
plot2 <- LabelPoints(plot = plot1, 
                     points = top10.hvg, 
                     xnudge = 0, ynudge = 0)
plot2
dev.off()


# saveRDS(scrna, file = sprintf("%s/VST.rds", output_data))




# Step 4: PCA - dimentionality reduction ----------------------------------

# scrna <- RunPCA(object = scrna, npcs = 100, verbose = FALSE)
scrna <- RunPCA(scrna, features = VariableFeatures(object = scrna))

## this is to score each gene in the dataset 
## including genes not included in the PCA
## based on their correlation with the calculated components
# scrna <- ProjectDim(object = scrna)


output_pcaplot <- paste(outdir, "plot", "PCA", sep = "/")
if (!dir.exists(output_pcaplot)) {
  dir.create(output_pcaplot, recursive = TRUE)
}


## plot PCA loading graphs
tiff(sprintf("%s/VizDimLoadings.tiff", output_pcaplot), 
     width = 15, height = 15, units = "in", res = 100)
VizDimLoadings(object = scrna, dims = 1:4, col = 2)
dev.off()

## PCA Heatmap
tiff(sprintf("%s/PCA.heatmap.multi.tiff", output_pcaplot), 
     width = 15, height = 15, units = "in", res = 300)
## onl 59 cells
DimHeatmap(object = scrna, dims = 1:16, cells = 500, 
           balanced = TRUE, ncol = 4)
dev.off()

## PCA dimension plot
tiff(sprintf("%s/PCA.dimplot.tiff", output_pcaplot), 
     width = 10, height = 8, units = "in", res = 90)
DimPlot(scrna, reduction = "pca")
dev.off()



PClist_1 <- names(sort(Loadings(object=scrna, reduction="pca")[,1],
                       decreasing=TRUE))
cat(head(PClist_1, 10))


## Elbow plot 

tiff(sprintf("%s/PCA.elbowplot.tiff", output_pcaplot), 
     width = 10, height = 8, units = "in", res = 90)
ElbowPlot(object = scrna)
dev.off()



scrna <- ScoreJackStraw(scrna, dims = 1:30)

tiff(sprintf("%s/PCA.jackstrawplot.tiff", output_pcaplot), 
     width = 10, height = 7, units = "in", res = 90)
JackStrawPlot(scrna, dims = 1:30)
dev.off()


# get p-value for each PC
scrna@reductions$pca@jackstraw@overall.p.values %>% 
  write.csv("output/PCA.jackstraw.scores.csv", row.names = TRUE)




# Step 5: generate 2d layouts - tSNE and UMAP -----------------------------

# nPC = 10 
## based on the graphs
nPC <- 15
scrna <- RunUMAP(object = scrna, reduction = "pca", dims = 1:nPC)
scrna <- RunTSNE(object = scrna, reduction = "pca", dims = 1:nPC, 
                 check_duplicates = FALSE)




output_umapplot <- paste(outdir, "plot", "UMAP", sep = "/")
if (!dir.exists(output_umapplot)) {
  dir.create(output_umapplot, recursive = TRUE)
}


tiff(sprintf("%s/UMAP.nPC%d.tiff", output_umapplot, nPC), 
     width = 15, height = 7, units = "in", res = 90)
p1 <- DimPlot(object = scrna, 
              reduction = "tsne", 
              group.by = "DataSet", 
              pt.size=0.1)
p2 <- DimPlot(object = scrna, 
              reduction = "umap", 
              group.by = "DataSet", 
              pt.size=0.1)
plot_grid(p1, p2)
dev.off()



# a useful color palette
feature.pal = rev(colorRampPalette(brewer.pal(11,"Spectral"))(50))

tiff(sprintf("%s/umap.%d.colorby.UMI.tiff", output_umapplot, nPC), 
     width = 15, height = 7, units = "in", res = 90)
p1 <- FeaturePlot(object = scrna, features = c("nCount_RNA"), 
            cols = feature.pal, 
            pt.size = 0.1, 
            reduction = "tsne") 
p2 <- FeaturePlot(object = scrna, features = c("nCount_RNA"), 
            cols = feature.pal, 
            pt.size = 0.1, 
            reduction = "umap") 
plot_grid(p1, p2)
dev.off()



PCs <- paste0("PC_", 1:nPC)
redblue <- c("blue","gray","red")
p <- lapply(PCs, function(x) {
  FeaturePlot(object = scrna, 
                    features = x, 
                    cols = redblue, 
                    pt.size = 0.1, 
                    reduction = "tsne")
})

tiff(sprintf("%s/umap.%d.colorby.PCs.tiff", 
             output_umapplot, nPC),
     width = 18, height = 15, units = "in", res = 90)
plot_grid(plotlist = p, ncol = 4)
dev.off()
# p2 <<- FeaturePlot(object = scrna, 
#                   features = x, 
#                   cols = redblue, 
#                   pt.size = 0.1, 
#                   reduction = "umap")


output_geneplot <- paste(outdir, "plot", "gene", sep = "/")
if (!dir.exists(output_geneplot)) {
  dir.create(output_geneplot, recursive = TRUE)
}

# R script to read in a table of marker genes and color the cells 
# of the umap according to the expression levels of those genes

## tissue resident t cells
## regulatory t cells
## Th17 cells

gene_list_raw <- readr::read_csv("data/gene_lists_human_180502.csv") %>% 
  filter(Name %in% rownames(scrna)) %>% 
  mutate(List = gsub(" |/", "_", List)) %>% 
  ## add custom gene markers
  bind_rows(c(List = "TRM cells", Name = "CD103", Ensembl = ""), # CD8+/skin
            c(List = "TRM cells", Name = "CD69", Ensembl = ""), # skin
            c(List = "TRM cells", Name = "CD49", Ensembl = ""), 
            c(List = "TRM cells", Name = "CD49A", Ensembl = ""), 
            c(List = "TRM cells", Name = "CD122", Ensembl = ""), 
            c(List = "TRM cells", Name = "PD-1", Ensembl = ""), 
            c(List = "TRegs", Name = "CD3", Ensembl = ""), 
            c(List = "TRegs", Name = "CD25", Ensembl = ""), 
            c(List = "TRegs", Name = "CD39", Ensembl = ""), 
            c(List = "TRegs", Name = "CD73", Ensembl = ""),
            c(List = "TRegs", Name = "CD127", Ensembl = ""),
            c(List = "TRegs", Name = "GITR", Ensembl = ""), 
            c(List = "TRegs", Name = "LAG-3", Ensembl = ""), 
            c(List = "TRegs", Name = "LRRC32", Ensembl = ""), 
            c(List = "TRegs", Name = "FOXP3", Ensembl = ""), 
            c(List = "TRegs", Name = "CTLA-4", Ensembl = ""), 
            c(List = "Th17 cells", Name = "APOD", Ensembl = ""), 
            c(List = "Th17 cells", Name = "C1QL1", Ensembl = ""), 
            c(List = "Th17 cells", Name = "CTSL", Ensembl = "")) 


gene_split <- split(gene_list_raw$Name, gene_list_raw$List)

lapply(names(gene_split), function(x) {
  genesToPlot <- gene_list_raw$Name[gene_list_raw$List == x]
  ng = length(genesToPlot); # number of genes
  
  h = 0;
  w = 0;
  print(ng)
  if (ng > 1) {
    w = 11; # two columns
    h = 5*(floor(ng/2) + ng %% 2); # number of rows
    
    outfile <- sprintf("%s/tsne.%s.tiff", output_geneplot, x)
    print(outfile)
    tiff(outfile, width = w, height = h, units = "in", res = 90)
    p <- FeaturePlot(object = scrna, 
                     features = genesToPlot, 
                     cols = c("gray","red3"), 
                     ncol = 2,
                     reduction = "tsne")
    print(p)
    dev.off()
    
    outfile <- sprintf("%s/umap.%s.tiff", output_geneplot, x)
    print(outfile)
    tiff(outfile, width = w, height = h, units = "in", res = 90)
    p <- FeaturePlot(object = scrna, 
                features = genesToPlot, 
                cols = c("gray","red3"), 
                ncol = 2,
                reduction = "umap")
    print(p)
    dev.off()
  } else {
    w = 5;
    h = 5;
    
    outfile <- sprintf("%s/tsne.%s.tiff", output_geneplot, x)
    tiff(outfile, width = w, height = h, units = "in", res = 90)
    p <- FeaturePlot(object = scrna, 
                     features = genesToPlot, 
                     cols = c("gray","red3"), 
                     ncol = 1,
                     reduction = "tsne")
    print(p)
    dev.off()
    
    outfile <- sprintf("%s/umap.%s.tiff", output_geneplot, x)
    print(outfile)
    tiff(outfile, width = w, height = h, units = "in", res = 90)
    p <- FeaturePlot(object = scrna, 
                features = genesToPlot, 
                cols = c("gray","red3"), 
                ncol = 1,
                reduction = "umap")
    print(p)
    dev.off()
  }

})


# Step 6: Find clusters and marker genes ----------------------------------

# nPC <- 10
cluster.res <- 0.2
scrna <- FindNeighbors(object=scrna, dims=1:nPC)
scrna <- FindClusters(object=scrna, resolution=cluster.res)


scrna[[sprintf("ClusterNames_%.1f_%dPC", cluster.res, nPC)]] <- Idents(object = scrna)
str(scrna@meta.data)


# automatically get the number of clusters from a specific clustering run
n.graph <- length(unique(scrna[[sprintf("ClusterNames_%.1f_%dPC",cluster.res, nPC)]][,1]))
n.graph



output_clusterplot <- paste(outdir, "plot", "cluster", sep = "/")
if (!dir.exists(output_clusterplot)) {
  dir.create(output_clusterplot, recursive = TRUE)
}

tiff(sprintf("%s/umap.clusters.tiff", output_clusterplot), 
     width = 10, height = 7, units = "in", res = 90)
rainbow.colors = rainbow(n.graph, s=0.6, v=0.9) # color palette
p <- DimPlot(object = scrna, reduction = "umap", 
             group.by = "seurat_clusters", cols = rainbow.colors, 
             pt.size=0.1, label=TRUE)
print(p)
dev.off()



## find sample specific clusters
cluster.breakdown <- table(scrna@meta.data$DataSet, 
                           scrna@meta.data$seurat_clusters)
cluster.breakdown
write.csv(cluster.breakdown, "output/sample_specific_cluster.csv", 
          row.names = TRUE)




# Step 7: DEG for clusters ------------------------------------------------

# find markers for every cluster compared to all remaining cells\
# report both positive and negative ones
DEGs <- FindAllMarkers(object = scrna, 
                       logfc.threshold = 1, 
                       min.diff.pct = .2)
DEGs %>%
  group_by(cluster) %>%
  slice_max(n = 100, order_by = avg_log2FC) %>% 
  write.csv("output/DEGs_top10.csv", row.names = FALSE)


## DEGs heatmap for top10 genes
DEGs.top10 <- DEGs %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log2FC) 


tiff("output/plot/DEGs.heatmap.tiff", 
     width = 15, height = 20, units = "in", res = 100)
p <- DoHeatmap(scrna, features =  DEGs.top10$gene, 
               slot = "scale.data", disp.min = -2, 
               disp.max = 2, group.by = "ident", 
               group.bar = TRUE) + 
  scale_fill_gradientn(colors = c("blue", "white", "red"))
print(p)
dev.off()



# Step 8: automatically assign cell types ---------------------------------

## https://github.com/IanevskiAleksandr/sc-type



# load libraries and functions
lapply(c("dplyr","Seurat","HGNChelper"), library, character.only = T)
# load gene set preparation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")
# load cell type annotation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")

# DB file
db_ = "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";
tissue = "Immune system" # e.g. Immune system, Liver, Pancreas, Kidney, Eye, Brain

# prepare gene sets
gs_list = gene_sets_prepare(db_, tissue)


pbmc <- scrna

# get cell-type by cell matrix
es.max = sctype_score(scRNAseqData = pbmc[["RNA"]]@scale.data, scaled = TRUE, 
                      gs = gs_list$gs_positive, gs2 = gs_list$gs_negative) 

# NOTE: scRNAseqData parameter should correspond to your input scRNA-seq matrix. 
# In case Seurat is used, it is either pbmc[["RNA"]]@scale.data (default), pbmc[["SCT"]]@scale.data, in case sctransform is used for normalization,
# or pbmc[["integrated"]]@scale.data, in case a joint analysis of multiple single-cell datasets is performed.

# merge by cluster
cL_resutls = do.call("rbind", lapply(unique(pbmc@meta.data$seurat_clusters), function(cl){
  es.max.cl = sort(rowSums(es.max[ ,rownames(pbmc@meta.data[pbmc@meta.data$seurat_clusters==cl, ])]), decreasing = !0)
  head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(pbmc@meta.data$seurat_clusters==cl)), 10)
}))
sctype_scores = cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

# set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] = "Unknown"
print(sctype_scores[,1:3])
sum(sctype_scores$ncells)


pbmc@meta.data$customclassif = ""
for(j in unique(sctype_scores$cluster)){
  cl_type = sctype_scores[sctype_scores$cluster==j,]; 
  pbmc@meta.data$customclassif[pbmc@meta.data$seurat_clusters == j] = as.character(cl_type$type[1])
}


tiff("output/plot/tsne.celltypes.tiff", 
     width = 10, height = 6, units = "in", res = 300)
p <- DimPlot(pbmc, reduction = "tsne", label = TRUE, repel = TRUE, group.by = 'customclassif') 
print(p)
dev.off()

tiff("output/plot/umap.celltypes.tiff", 
     width = 10, height = 6, units = "in", res = 300)
p <- DimPlot(pbmc, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'customclassif')
print(p)
dev.off()



# load libraries
lapply(c("ggraph","igraph","tidyverse", "data.tree"), library, character.only = T)

# prepare edges
cL_resutls=cL_resutls[order(cL_resutls$cluster),]; edges = cL_resutls; edges$type = paste0(edges$type,"_",edges$cluster); edges$cluster = paste0("cluster ", edges$cluster); edges = edges[,c("cluster", "type")]; colnames(edges) = c("from", "to"); rownames(edges) <- NULL

# prepare nodes
nodes_lvl1 = sctype_scores[,c("cluster", "ncells")]; nodes_lvl1$cluster = paste0("cluster ", nodes_lvl1$cluster); nodes_lvl1$Colour = "#f1f1ef"; nodes_lvl1$ord = 1; nodes_lvl1$realname = nodes_lvl1$cluster; nodes_lvl1 = as.data.frame(nodes_lvl1); nodes_lvl2 = c(); 
ccolss= c("#5f75ae","#92bbb8","#64a841","#e5486e","#de8e06","#eccf5a","#b5aa0f","#e4b680","#7ba39d","#b15928","#ffff99", "#6a3d9a","#cab2d6","#ff7f00","#fdbf6f","#e31a1c","#fb9a99","#33a02c","#b2df8a","#1f78b4","#a6cee3")
for (i in 1:length(unique(cL_resutls$cluster))){
  dt_tmp = cL_resutls[cL_resutls$cluster == unique(cL_resutls$cluster)[i], ]; nodes_lvl2 = rbind(nodes_lvl2, data.frame(cluster = paste0(dt_tmp$type,"_",dt_tmp$cluster), ncells = dt_tmp$scores, Colour = ccolss[i], ord = 2, realname = dt_tmp$type))
}
nodes = rbind(nodes_lvl1, nodes_lvl2); nodes$ncells[nodes$ncells<1] = 1;
files_db = openxlsx::read.xlsx(db_)[,c("cellName","shortName")]; files_db = unique(files_db); nodes = merge(nodes, files_db, all.x = T, all.y = F, by.x = "realname", by.y = "cellName", sort = F)
nodes$shortName[is.na(nodes$shortName)] = nodes$realname[is.na(nodes$shortName)]; nodes = nodes[,c("cluster", "ncells", "Colour", "ord", "shortName", "realname")]

mygraph <- graph_from_data_frame(edges, vertices=nodes)

# Make the graph
gggr<- ggraph(mygraph, layout = 'circlepack', weight=I(ncells)) + 
  geom_node_circle(aes(filter=ord==1,fill=I("#F5F5F5"), colour=I("#D3D3D3")), alpha=0.9) + geom_node_circle(aes(filter=ord==2,fill=I(Colour), colour=I("#D3D3D3")), alpha=0.9) +
  theme_void() + geom_node_text(aes(filter=ord==2, label=shortName, colour=I("#ffffff"), fill="white", repel = !1, parse = T, size = I(log(ncells,25)*1.5)))+ geom_node_label(aes(filter=ord==1,  label=shortName, colour=I("#000000"), size = I(3), fill="white", parse = T), repel = !0, segment.linetype="dotted")

tiff("output/plot/umap.celltypes.bubble.tiff", 
     width = 15, height = 15, units = "in", res = 100)
p <- DimPlot(pbmc, reduction = "umap", label = TRUE, repel = TRUE, 
             cols = ccolss, group.by = 'customclassif') /
  gggr
print(p)
dev.off()


# load auto-detection function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/auto_detect_tissue_type.R")

# guess a tissue type
tissue_guess = auto_detect_tissue_type(path_to_db_file = db_, 
                                       seuratObject = pbmc, assay = "RNA", 
                                       scaled = TRUE)  
tissue_guess %>% 
  write.csv("output/tissue_guess_score.csv", row.names = FALSE)

